package main

import (
	"bytes"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"time"

	"github.com/google/go-attestation/attest"
)

func main() {
	// Create a new HTTP client with a timeout
	c := http.Client{Timeout: time.Duration(10) * time.Second}

	// Initialize TPM access
	config := &attest.OpenConfig{}     // Configures settings to open the TPM
	tpm, err := attest.OpenTPM(config) // Opens the TPM
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error opening the TPM: %v\n", err)
		os.Exit(1)
	}
	defer tpm.Close()

	// Get endorsement keys (EKs) from the TPM
	eks, err := tpm.EKs() // Returns the EKs stored in the TPM
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting EKs from TPM: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "There is %d EKs in TPM 2.0 chip\n", len(eks))
	ek := eks[0]

	// Get TPM information
	tpmInfo, err := tpm.Info() // Gets all info from the TPM, manufacturer, version, etc.
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting Vendor Name from TPM: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "Version of TPM 2.0 chip : %v\n", tpmInfo.Version)
	fmt.Fprintf(os.Stdout, "Interface of TPM 2.0 chip : %v\n", tpmInfo.Interface)
	fmt.Fprintf(os.Stdout, "Vendor info of TPM 2.0 chip : %v\n", tpmInfo.VendorInfo)
	fmt.Fprintf(os.Stdout, "Vendor Name of TPM 2.0 chip : %s\n", tpmInfo.Manufacturer.String())
	fmt.Fprintf(os.Stdout, "Firmware version of TPM 2.0 chip : %d.%d\n", tpmInfo.FirmwareVersionMajor, tpmInfo.FirmwareVersionMinor)

	// Generate a new Attestation Key (AK)
	akConfig := &attest.AKConfig{} // Encapsulates config for the AK key
	ak, err := tpm.NewAK(akConfig) // Create new attestation key
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating AK in TPM: %v\n", err)
		os.Exit(1)
	}
	akAttestParams := ak.AttestationParameters() // Returns info about the AK for credential activation challenge
	akBytes, err := ak.Marshal()                 // Serializes the AK
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error marshalling AK: %v\n", err)
		ak.Close(tpm)
		os.Exit(1)
	}

	// Next step: Send attestation parameters to Attestation CA and wait for OK
	type Message struct {
		TPMVersion attest.TPMVersion
		EKPublic   []byte
		EKCert     x509.Certificate
		AK         attest.AttestationParameters
	}

	// Convert the EK public key to PEM format
	derBytes, err := x509.MarshalPKIXPublicKey(ek.Public)
	if err != nil {
		fmt.Print(err)
	}
	pemBytes := pem.EncodeToMemory(&pem.Block{Type: "PUBLIC KEY", Bytes: derBytes})
	fmt.Print("\nSending the attestation parameters to server...\n")

	// Create the message with attestation parameters and send it to the server
	data2send := Message{attest.TPMVersion20, pemBytes, *eks[0].Certificate, akAttestParams}
	m2s, _ := json.Marshal(data2send)
	//fmt.Printf("Sending JSON data to server: %s\n", string(m2s))

	req, err := http.NewRequest("POST", "http://localhost:8080", bytes.NewBuffer(m2s))
	if err != nil {
		fmt.Print(err)
		return
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := c.Do(req)
	if err != nil {
		fmt.Print(err)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Print(err)
		return
	}

	// Structure to receive the encrypted credentials from the server
	type EnCred struct {
		EncryptedCredential attest.EncryptedCredential
	}
	var ec EnCred

	// var ec attest.EncryptedCredential ??

	fmt.Print("Receiving encrypted credentials from server...\n")

	//fmt.Printf("Encrypted Credentials Received: %s\n\n", string(body))
	err = json.Unmarshal(body, &ec)
	if err != nil {
		fmt.Println(err)
		return
	}

	// Client loads the previously created AK
	ak, err = tpm.LoadAK(akBytes)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading AK: %v\n", err)
		os.Exit(1)
	}

	// Decrypts the EnCred using the key, proving that the AK was generated by the same TPM as the EK
	secret, err := ak.ActivateCredential(tpm, ec.EncryptedCredential)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error activating Credential Activation Challenge: %v\n", err)
		os.Exit(1)
	}

	/* // Sends the decrypted secret back to the server
	//fmt.Printf("Decrypted secret correctly, sending it back: %x\n", secret)
	req, err = http.NewRequest("POST", "http://localhost:8080", bytes.NewBuffer(secret))
	if err != nil {
		fmt.Print(err)
		os.Exit(1)
	}
	req.Header.Set("Content-Type", "application/octet-stream")
	resp, err = c.Do(req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error returning answer for the Credential Activation Challenge: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Secret sent: %x\n", secret)
	defer resp.Body.Close()

	body, err = io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("Sending secret back to server: %x\n", secret) */
	c = http.Client{Timeout: time.Duration(10) * time.Second}
	req, err = http.NewRequest("POST", "http://localhost:8080", bytes.NewBuffer(secret))
	if err != nil {
		fmt.Print(err)
		os.Exit(1)
	}
	req.Header.Set("Content-Type", "application/octet-stream")

	// Verifica el tamaño de los datos que estás enviando
	fmt.Printf("Size of the data being sent: %d bytes\n", len(secret))

	resp, err = c.Do(req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error sending the secret: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	// Verifica que el servidor haya respondido correctamente
	body, err = io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading server response:", err)
		return
	}
	fmt.Printf("Response from server: %s\n", string(body))

	nonce := body
	fmt.Printf("Received nonce successfully:%s \n", string(nonce))

	// Perform the attestation: Full PCR read is performed
	fmt.Print("Starting attestation... \n")
	params, err := tpm.AttestPlatform(ak, []byte(nonce), &attest.PlatformAttestConfig{EventLog: []byte{0}})
	// params, err := tpm.AttestPlatform(ak, nonce, &attest.PlatformAttestConfig{EventLog: []byte{0}})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error attesting platform state: %v\n", err)
		return
	}
	// Send attestation parameters
	type attestParams struct {
		Parameters attest.PlatformParameters
		AKPublic   []byte
	}
	params2send := attestParams{*params, akBytes}
	p2s, _ := json.Marshal(params2send)
	req, err = http.NewRequest("POST", "http://localhost:8080", bytes.NewBuffer(p2s))
	if err != nil {
		fmt.Print(err)
		os.Exit(1)
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err = c.Do(req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error sending the attestation data to CA: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	fmt.Print("Sent attestation data to server... \n")
	ak.Close(tpm)

	body, err = io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	// Receive the UID from the Attestation CA to be able to communicate with ACME CA
	SessionID := string(body)

	// Next step would be calling the ACME Client to start the ACME challenge
	// There, the UID would be checked for validity
	cmd := exec.Command("./test-device-attest", "-serial", SessionID)
	stdout, err := cmd.Output()

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	// Print the output
	fmt.Println(string(stdout))

	os.Exit(0)
}
